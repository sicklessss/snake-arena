<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Snake Arena Live</title>
    <style>
        body { background: #000; color: #0f0; font-family: sans-serif; text-align: center; }
        canvas { border: 2px solid #333; background: #111; margin-top: 20px; }
    </style>
</head>
<body>
    <h1 id="status">Connecting...</h1>
    <canvas id="arena" width="800" height="800"></canvas>
    
    <script>
        const canvas = document.getElementById('arena');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        function connect() {
            // Auto-detect: if https, use wss; if http, use ws
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = location.host; // e.g. snake-arena.onrender.com
            const ws = new WebSocket(`${protocol}//${host}`);
            
            ws.onopen = () => { status.innerText = "LIVE: Connected"; status.style.color = "#0f0"; };
            ws.onclose = () => { status.innerText = "Disconnected"; status.style.color = "#f00"; setTimeout(connect, 1000); };
            
            ws.onmessage = (e) => {
                try {
                    const msg = JSON.parse(e.data);
                    if (msg.type === 'update') {
                        draw(msg.state);
                    }
                } catch(err) { console.error(err); }
            };
        }

        function draw(state) {
            // 1. Clear
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 2. Draw Turn Counter (Background)
            ctx.fillStyle = '#222';
            ctx.font = 'bold 200px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(state.turn, 400, 400);

            // 3. Draw Grid
            const TILE = canvas.width / state.gridSize;

            // 4. Draw Food
            ctx.fillStyle = '#f00';
            state.food.forEach(f => {
                ctx.beginPath();
                ctx.arc(f.x*TILE + TILE/2, f.y*TILE + TILE/2, TILE/2-2, 0, Math.PI*2);
                ctx.fill();
            });

            // 5. Draw Players
            // Sort by score for layering (and leaderboard)
            const sortedPlayers = state.players.sort((a,b) => b.score - a.score);
            
            sortedPlayers.forEach(p => {
                if (!p.alive) return; // Don't draw dead bodies on map? Or maybe draw gray?
                ctx.fillStyle = p.color;
                p.body.forEach(b => {
                    ctx.fillRect(b.x*TILE+1, b.y*TILE+1, TILE-2, TILE-2);
                });
                const head = p.body[0];
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.fillText(p.name, head.x*TILE + TILE/2, head.y*TILE - 5);
            });
            
            // 6. Game Over Overlay
            if (state.gameState === 'GAMEOVER') {
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.font = 'bold 60px Arial';
                ctx.fillText(`ðŸ† WINNER: ${state.winner} ðŸ†`, 400, 150);
                
                // Leaderboard
                ctx.fillStyle = '#fff';
                ctx.font = '30px Arial';
                ctx.textAlign = 'left';
                let y = 250;
                ctx.fillText("--- LEADERBOARD ---", 250, y);
                y += 50;
                
                sortedPlayers.slice(0, 10).forEach((p, i) => {
                    ctx.fillStyle = p.alive ? '#0f0' : '#666'; // Green if alive (winner), gray if dead
                    ctx.fillText(`#${i+1} ${p.name} - Score: ${p.score}`, 250, y);
                    y += 40;
                });
                
                status.innerText = "GAME OVER - Resetting in 5s...";
                return;
            }
            
            status.innerText = `Turn: ${state.turn} | Players: ${state.players.filter(p=>p.alive).length}`;
        }

        connect();
    </script>
</body>
</html>