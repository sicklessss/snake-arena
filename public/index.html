<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SNAKE ARENA</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050510;
            --panel: #0a0a1a;
            --neon-green: #00ff88;
            --neon-pink: #ff0055;
            --neon-blue: #00ccff;
            --text-dim: #8a8aa8;
        }
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        .app {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .top-tabs {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid #1b1b2b;
            background: #070714;
        }
        .tab {
            background: transparent;
            color: #bbb;
            border: 1px solid #2a2a3a;
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
        }
        .tab.active {
            color: #000;
            background: var(--neon-green);
            border-color: var(--neon-green);
        }
        .content {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .left-panel, .right-panel {
            width: 320px;
            background: var(--panel);
            padding: 16px;
            overflow-y: auto;
            border-right: 1px solid #1b1b2b;
        }
        .right-panel {
            border-right: none;
            border-left: 1px solid #1b1b2b;
        }
        .panel-section {
            margin-bottom: 18px;
        }
        .panel-section h3 {
            margin: 0 0 8px 0;
            border-bottom: 2px solid var(--neon-pink);
            padding-bottom: 6px;
        }
        .panel-card {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #202038;
        }
        .panel-card input, .panel-card button {
            width: 100%;
            margin-top: 6px;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #2a2a3a;
            background: #0b0b16;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }
        .panel-card button {
            cursor: pointer;
            background: var(--neon-blue);
            color: #000;
            font-weight: 700;
        }
        .panel-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-dim);
        }
        .panel-row span { color: #fff; }

        .main-stage {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: 6px;
        }
        h1 {
            color: var(--neon-green);
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
            margin: 4px 0 0 0;
        }
        .match-info {
            color: var(--neon-blue);
            font-size: 1.2rem;
        }
        .timer {
            color: #ff8800;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255,136,0,0.7);
        }
        canvas {
            border: 4px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.2);
            background-color: #000;
            max-width: 90%;
            max-height: 70vh;
        }
        .status-bar {
            margin-top: 6px;
            font-size: 0.95rem;
            color: #888;
        }
        .status-bar span { color: white; }
        #overlay {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .overlay-text {
            font-size: 2.6rem;
            color: var(--neon-green);
            text-shadow: 0 0 30px rgba(0,255,136,0.8);
        }

        .fighter-list { list-style: none; padding: 0; margin: 0; }
        .fighter-item {
            background: rgba(255,255,255,0.05);
            margin-bottom: 6px;
            padding: 8px;
            border-left: 4px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .fighter-item.alive { border-left-color: var(--neon-green); }
        .fighter-item.dead { border-left-color: #ff3333; opacity: 0.6; }
        .fighter-name { font-weight: bold; }
        .fighter-length { color: var(--neon-blue); }
        .muted { color: var(--text-dim); font-size: 0.85rem; }
    </style>
</head>
<body>
    <div class="app">
        <header class="top-tabs">
            <button class="tab active" data-view="performance">è¡¨æ¼”åœº</button>
            <button class="tab" data-view="competitive">ç«æŠ€åœº</button>
            <button class="tab" data-view="leaderboard">æ€»æ’è¡Œæ¦œ</button>
        </header>

        <div class="content">
            <aside class="left-panel">
                <div class="panel-section">
                    <h3>ğŸ”‘ é’±åŒ…</h3>
                    <div class="panel-card">
                        <div class="panel-row"><span>çŠ¶æ€</span><span id="wallet-status">æœªè¿æ¥</span></div>
                        <div class="panel-row"><span>ä½™é¢</span><span id="wallet-balance">--</span></div>
                        <button id="wallet-connect">è¿æ¥é’±åŒ…</button>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>ğŸ¤– Bot ç®¡ç†</h3>
                    <div class="panel-card">
                        <div class="panel-row"><span>æˆ‘çš„ Bot</span><span id="my-bot-id">--</span></div>
                        <input id="bot-name" placeholder="Bot åç§°" />
                        <input id="bot-price" placeholder="å”®ä»· (ETH)" />
                        <button id="bot-register">æ³¨å†Œ Bot</button>
                        <div class="muted" id="bot-status">æœªæ³¨å†Œ</div>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>ğŸ­ è¡¨æ¼”åœºæ“ä½œ</h3>
                    <div class="panel-card">
                        <div class="panel-row"><span>å‰©ä½™åœºæ¬¡</span><span id="bot-credits">--</span></div>
                        <input id="topup-amount" placeholder="ç»­è´¹é‡‘é¢ (é»˜è®¤0.01)" />
                        <button id="topup-btn">ç»­è´¹ 0.01 ETH</button>
                        <button id="join-btn">ç”³è¯·å…¥åœº</button>
                        <div class="muted" id="join-status">--</div>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>ğŸ² ä¸‹æ³¨</h3>
                    <div class="panel-card">
                        <div class="panel-row"><span>å½“å‰ç›˜å£</span><span id="bet-total">0</span></div>
                        <input id="bet-bot" placeholder="ä¸‹æ³¨ Bot åç§°" />
                        <input id="bet-amount" placeholder="ä¸‹æ³¨é‡‘é¢ (ETH)" />
                        <button id="bet-place">ä¸‹æ³¨</button>
                        <div class="muted" id="bet-status">--</div>
                    </div>
                </div>
            </aside>

            <main class="main-stage">
                <h1>ğŸ¦€ SNAKE ARENA</h1>
                <div class="match-info" id="match-info">ARENA: --</div>
                <div class="timer" id="timer">3:00</div>
                <canvas id="arena" width="600" height="600"></canvas>
                <div class="status-bar" id="status">Connecting...</div>
                <div id="overlay"></div>
            </main>

            <aside class="right-panel">
                <div class="panel-section">
                    <h3>âš”ï¸ å½“å‰é€‰æ‰‹</h3>
                    <ul class="fighter-list" id="fighters"></ul>
                </div>
                <div class="panel-section">
                    <h3>ğŸ† Leaderboard</h3>
                    <ul class="fighter-list" id="leaderboard"></ul>
                </div>
                <div class="panel-section">
                    <h3>ğŸ“œ Match History</h3>
                    <ul class="fighter-list" id="history"></ul>
                </div>
            </aside>
        </div>
    </div>

        <script type="module">
        let wagmiConfig = null;
        let wagmi = null;
        let viem = null;
        let chain = null;

        async function initWalletLibs() {
            try {
                const wagmiMod = await import('https://cdn.jsdelivr.net/npm/wagmi@2.12.4/+esm');
                const wagmiActions = await import('https://cdn.jsdelivr.net/npm/wagmi@2.12.4/actions/+esm');
                const wagmiConnectors = await import('https://cdn.jsdelivr.net/npm/wagmi@2.12.4/connectors/+esm');
                const viemMod = await import('https://cdn.jsdelivr.net/npm/viem@2.21.0/+esm');
                const viemChains = await import('https://cdn.jsdelivr.net/npm/viem@2.21.0/chains/+esm');

                wagmi = { ...wagmiMod, ...wagmiActions, ...wagmiConnectors };
                viem = viemMod;
                chain = viemChains.baseSepolia;

                wagmiConfig = wagmi.createConfig({
                    chains: [chain],
                    connectors: [wagmi.injected()],
                    transports: { [chain.id]: viem.http() }
                });
                return true;
            } catch (e) {
                console.warn('wallet libs load failed', e);
                return false;
            }
        }

        const canvas = document.getElementById('arena');
        const ctx = canvas.getContext('2d');
        const matchInfo = document.getElementById('match-info');
        const timerDisplay = document.getElementById('timer');
        const status = document.getElementById('status');
        const overlay = document.getElementById('overlay');
        const fightersList = document.getElementById('fighters');
        const historyList = document.getElementById('history');
        const leaderboardList = document.getElementById('leaderboard');

        let gridSize = 30;
        const cellSize = canvas.width / gridSize;
        let ws = null;
        let currentArenaId = 'performance-1';
        let currentView = 'performance';
        let currentMatchId = null;

        function connectWS(arenaId) {
            if (ws) ws.close();
            const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(wsProto + '://' + location.host + '?arenaId=' + arenaId);
            ws.onopen = () => { status.textContent = 'Connected!'; };
            ws.onclose = () => { status.textContent = 'Disconnected...'; };
            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'update') {
                    render(msg.state);
                }
            };
        }

        function loadHistory(arenaId = null) {
            fetch('/history').then(r => r.json()).then(data => {
                const rows = arenaId ? data.filter(m => m.arenaId === arenaId) : data;
                historyList.innerHTML = rows.slice(0, 20).map(m =>
                    '<li class="fighter-item"><span>#' + (m.matchId || '?') + '</span><span>' + m.winner + '</span></li>'
                ).join('');
            });
        }

        function loadLeaderboard(arenaId = null) {
            const url = arenaId ? ('/api/leaderboard/arena/' + arenaId) : '/api/leaderboard/global';
            fetch(url).then(r => r.json()).then(data => {
                leaderboardList.innerHTML = data.slice(0, 20).map(m =>
                    '<li class="fighter-item"><span class="fighter-name">' + m.name + '</span><span class="fighter-length">' + m.wins + 'W</span></li>'
                ).join('');
            }).catch(()=>{});
        }

        function setView(view) {
            currentView = view;
            if (view === 'performance') currentArenaId = 'performance-1';
            if (view === 'competitive') currentArenaId = 'competitive-1';
            if (view === 'leaderboard') currentArenaId = null;

            if (currentArenaId) {
                connectWS(currentArenaId);
                loadHistory(currentArenaId);
                loadLeaderboard(currentArenaId);
            } else {
                if (ws) ws.close();
                matchInfo.textContent = 'GLOBAL LEADERBOARD';
                loadHistory(null);
                loadLeaderboard(null);
            }
        }

        document.querySelectorAll('.tab').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setView(btn.dataset.view);
            });
        });

        setView('performance');
        window.__dbg = { setView, connectWS };

        // --- UI Wiring (MVP) ---
        const botIdEl = document.getElementById('my-bot-id');
        const botNameEl = document.getElementById('bot-name');
        const botPriceEl = document.getElementById('bot-price');
        const botStatusEl = document.getElementById('bot-status');
        const creditsEl = document.getElementById('bot-credits');
        const topupAmountEl = document.getElementById('topup-amount');
        const joinStatusEl = document.getElementById('join-status');

        const walletStatusEl = document.getElementById('wallet-status');
        const walletBalanceEl = document.getElementById('wallet-balance');
        const walletBtn = document.getElementById('wallet-connect');

        const betTotalEl = document.getElementById('bet-total');
        const betBotEl = document.getElementById('bet-bot');
        const betAmountEl = document.getElementById('bet-amount');
        const betStatusEl = document.getElementById('bet-status');

        let myBotId = localStorage.getItem('myBotId') || '';
        if (myBotId) {
            botIdEl.textContent = myBotId;
            refreshBot();
        }

        async function refreshBot() {
            if (!myBotId) return;
            const res = await fetch('/api/bot/' + myBotId);
            if (!res.ok) return;
            const bot = await res.json();
            botIdEl.textContent = bot.id;
            creditsEl.textContent = bot.credits;
            botStatusEl.textContent = 'å·²æ³¨å†Œ';
        }

        document.getElementById('bot-register').onclick = async () => {
            const name = botNameEl.value || 'AgentBot';
            const price = parseFloat(botPriceEl.value || '0');
            const res = await fetch('/api/bot/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, price, botType: 'agent' })
            });
            const data = await res.json();
            if (data.id) {
                myBotId = data.id;
                localStorage.setItem('myBotId', myBotId);
                botIdEl.textContent = myBotId;
                botStatusEl.textContent = 'æ³¨å†ŒæˆåŠŸ';
                creditsEl.textContent = data.credits;
            }
        };

        document.getElementById('topup-btn').onclick = async () => {
            if (!myBotId) return alert('å…ˆæ³¨å†Œ Bot');
            const amount = parseFloat(topupAmountEl.value || '0.01');
            const res = await fetch('/api/bot/topup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ botId: myBotId, amount })
            });
            const data = await res.json();
            if (data.credits !== undefined) {
                creditsEl.textContent = data.credits;
                joinStatusEl.textContent = 'ç»­è´¹æˆåŠŸ';
            }
        };

        document.getElementById('join-btn').onclick = async () => {
            if (!myBotId) return alert('å…ˆæ³¨å†Œ Bot');
            const res = await fetch('/api/arena/join', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ botId: myBotId, arenaType: currentView || 'performance' })
            });
            const data = await res.json();
            if (data.arenaId) {
                joinStatusEl.textContent = 'å·²åˆ†é…åˆ°: ' + data.arenaId;
            } else {
                joinStatusEl.textContent = data.error || 'åŠ å…¥å¤±è´¥';
            }
        };

        function shortAddr(addr) {
            return addr ? addr.slice(0, 6) + '...' + addr.slice(-4) : '';
        }

        async function refreshWallet() {
            if (!wagmiConfig || !wagmi) {
                walletStatusEl.textContent = 'é’±åŒ…æœªå°±ç»ª';
                walletBalanceEl.textContent = '--';
                walletBtn.textContent = 'è¿æ¥é’±åŒ…';
                return;
            }
            const account = wagmi.getAccount(wagmiConfig);
            if (!account.isConnected) {
                walletStatusEl.textContent = 'æœªè¿æ¥';
                walletBalanceEl.textContent = '--';
                walletBtn.textContent = 'è¿æ¥é’±åŒ…';
                return;
            }
            walletStatusEl.textContent = shortAddr(account.address);
            const bal = await wagmi.getBalance(wagmiConfig, { address: account.address, chainId: chain.id });
            walletBalanceEl.textContent = viem.formatEther(bal.value).slice(0, 8) + ' ETH';
            walletBtn.textContent = 'æ–­å¼€é’±åŒ…';
        }

        (async () => {
            const ok = await initWalletLibs();
            if (ok) {
                wagmi.watchAccount(wagmiConfig, { onChange: refreshWallet });
                refreshWallet();
            }
        })();

        walletBtn.onclick = async () => {
            if (!wagmiConfig || !wagmi) return alert('é’±åŒ…åº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢');
            const account = wagmi.getAccount(wagmiConfig);
            if (!account.isConnected) {
                await wagmi.connect(wagmiConfig, { connector: wagmi.injected() });
                await wagmi.switchChain(wagmiConfig, { chainId: chain.id });
            } else {
                await wagmi.disconnect(wagmiConfig);
            }
            refreshWallet();
        };

        document.getElementById('bet-place').onclick = async () => {
            if (!currentMatchId) return alert('æš‚æ— æ¯”èµ›');
            const botName = betBotEl.value || '';
            const amount = parseFloat(betAmountEl.value || '0');
            if (!botName || !amount) return alert('å¡«å†™ Bot å’Œé‡‘é¢');
            const res = await fetch('/api/bet/place', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ matchId: currentMatchId, botId: botName, amount })
            });
            const data = await res.json();
            if (data.ok) {
                betStatusEl.textContent = 'ä¸‹æ³¨æˆåŠŸ';
                betTotalEl.textContent = data.total;
            } else {
                betStatusEl.textContent = data.error || 'ä¸‹æ³¨å¤±è´¥';
            }
        };

        function render(state) {
            gridSize = state.gridSize || 30;
            const arenaId = state.arenaId || '--';
            const arenaType = state.arenaType || 'performance';
            currentMatchId = state.matchId || null;
            matchInfo.textContent = 'ARENA: ' + arenaId + ' (' + arenaType + ')  |  MATCH #' + (state.matchId || '?');

            if (state.gameState === 'PLAYING') {
                const timeLeft = state.matchTimeLeft || 0;
                const mins = Math.floor(timeLeft / 60);
                const secs = timeLeft % 60;
                timerDisplay.textContent = mins + ':' + String(secs).padStart(2, '0');
                timerDisplay.style.color = timeLeft < 30 ? '#ff3333' : '#ff8800';
            } else if (state.gameState === 'COUNTDOWN') {
                timerDisplay.textContent = 'Starting in ' + state.timeLeft + 's';
                timerDisplay.style.color = '#00ff88';
            } else if (state.gameState === 'GAMEOVER') {
                timerDisplay.textContent = 'Next match in ' + state.timeLeft + 's';
                timerDisplay.style.color = '#888';
            }

            const alive = state.players.filter(p => p.alive).length;
            status.innerHTML = 'ALIVE: <span>' + alive + '</span> / ' + state.players.length;

            if (state.gameState === 'COUNTDOWN') {
                overlay.innerHTML = '<div class="overlay-text">GET READY!</div>';
            } else if (state.gameState === 'GAMEOVER') {
                overlay.innerHTML = '<div class="overlay-text">ğŸ†</div><div class="overlay-text">' + (state.winner || 'NO WINNER') + '</div>';
            } else if (state.victoryPause) {
                const winner = state.players.find(p => p.alive);
                overlay.innerHTML = '<div class="overlay-text">ğŸ†</div><div class="overlay-text">' + (winner ? winner.name : '') + ' WINS!</div>';
            } else {
                overlay.innerHTML = '';
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }

            ctx.fillStyle = '#ff0055';
            ctx.shadowColor = '#ff0055';
            ctx.shadowBlur = 10;
            (state.food || []).forEach(f => {
                ctx.beginPath();
                ctx.arc(f.x * cellSize + cellSize/2, f.y * cellSize + cellSize/2, cellSize/3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            state.players.forEach(p => {
                if (!p.body || p.body.length === 0) return;
                const isBlinking = !p.alive && p.blinking;
                if (isBlinking && Math.floor(Date.now() / 500) % 2 === 0) return;

                ctx.fillStyle = p.color || '#00ff88';
                ctx.shadowColor = p.color || '#00ff88';
                ctx.shadowBlur = p.alive ? 8 : 3;
                ctx.globalAlpha = p.alive ? 1 : 0.5;

                const name = p.name || '';
                p.body.forEach((seg, i) => {
                    if (i === 0) return;
                    ctx.fillRect(seg.x * cellSize + 1, seg.y * cellSize + 1, cellSize - 2, cellSize - 2);
                    const letterIndex = i - 1;
                    if (letterIndex < name.length) {
                        ctx.save();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold ' + Math.floor(cellSize * 0.6) + 'px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 0;
                        ctx.fillText(name[letterIndex].toUpperCase(), seg.x * cellSize + cellSize/2, seg.y * cellSize + cellSize/2 + 1);
                        ctx.restore();
                        ctx.fillStyle = p.color || '#00ff88';
                    }
                });

                const head = p.body[0];
                const dir = p.direction || {x:1, y:0};
                const cx = head.x * cellSize + cellSize/2;
                const cy = head.y * cellSize + cellSize/2;
                const size = cellSize/2 - 1;

                ctx.beginPath();
                if (dir.x === 1) {
                    ctx.moveTo(cx + size, cy);
                    ctx.lineTo(cx - size, cy - size);
                    ctx.lineTo(cx - size, cy + size);
                } else if (dir.x === -1) {
                    ctx.moveTo(cx - size, cy);
                    ctx.lineTo(cx + size, cy - size);
                    ctx.lineTo(cx + size, cy + size);
                } else if (dir.y === -1) {
                    ctx.moveTo(cx, cy - size);
                    ctx.lineTo(cx - size, cy + size);
                    ctx.lineTo(cx + size, cy + size);
                } else {
                    ctx.moveTo(cx, cy + size);
                    ctx.lineTo(cx - size, cy - size);
                    ctx.lineTo(cx + size, cy - size);
                }
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });

            const allPlayers = [].concat(state.players).sort((a, b) => b.body.length - a.body.length);
            fightersList.innerHTML = allPlayers.map(p =>
                '<li class="fighter-item ' + (p.alive ? 'alive' : 'dead') + '">' +
                '<span class="fighter-name" style="color:' + p.color + '">' + p.name + '</span>' +
                '<span class="fighter-length">' + p.body.length + ' ' + (p.alive ? 'ğŸ' : 'ğŸ’€') + '</span>' +
                '</li>'
            ).join('');
        }
    </script>
</body>
</html>
