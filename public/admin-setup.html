<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Snake Arena - Admin Setup</title>
<style>
  body { background: #0a0a1a; color: #00ff88; font-family: monospace; padding: 40px; max-width: 700px; margin: 0 auto; }
  h1 { color: #ff0055; }
  h2 { color: #00ffcc; margin-top: 30px; border-bottom: 1px solid #333; padding-bottom: 8px; }
  .card { background: #111; border: 1px solid #333; border-radius: 8px; padding: 20px; margin: 16px 0; }
  .field { margin: 10px 0; }
  .field label { display: block; color: #888; font-size: 12px; margin-bottom: 4px; }
  .field input { width: 100%; background: #0a0a1a; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 12px; box-sizing: border-box; }
  button { background: #ff0055; color: #fff; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 14px; font-family: monospace; margin-top: 8px; }
  button:hover { background: #cc0044; }
  button:disabled { background: #555; cursor: not-allowed; }
  .connect-btn { background: #0055ff; }
  .connect-btn:hover { background: #0044cc; }
  .status { margin-top: 12px; padding: 10px; border-radius: 4px; font-size: 13px; }
  .ok { background: #0a2a0a; color: #00ff88; border: 1px solid #00ff88; }
  .err { background: #2a0a0a; color: #ff4444; border: 1px solid #ff4444; }
  .info { background: #0a0a2a; color: #88aaff; border: 1px solid #4466ff; }
  .wallet-info { font-size: 12px; color: #888; margin-top: 8px; }
  a { color: #00ffcc; }
</style>
</head>
<body>

<h1>ğŸ”§ Snake Arena Admin Setup</h1>
<p style="color:#888">ç”¨ Owner é’±åŒ…å®Œæˆä¸¤æ­¥é“¾ä¸Šæ“ä½œï¼Œå…¨ç¨‹åœ¨æµè§ˆå™¨å®Œæˆï¼Œæ— éœ€å‘½ä»¤è¡Œã€‚</p>

<div class="card">
  <div class="field">
    <label>å½“å‰è¿æ¥é’±åŒ…</label>
    <div id="wallet-display" class="wallet-info">æœªè¿æ¥</div>
  </div>
  <button class="connect-btn" onclick="connectWallet()">ğŸ”— è¿æ¥ MetaMask</button>
  <div id="connect-status"></div>
</div>

<h2>ç¬¬ä¸€æ­¥ï¼šä¸º SnakeBot_v2_01 åˆ›å»ºé“¾ä¸Šè®°å½•</h2>
<div class="card">
  <p style="color:#888;font-size:13px">è°ƒç”¨ BotRegistry.createBot()ï¼Œè®©ç”¨æˆ·é’±åŒ…èƒ½æ­£å¸¸æ³¨å†Œè¿™ä¸ª Botã€‚</p>
  <div class="field">
    <label>_botId (bytes32) â€” å›ºå®šå€¼ï¼Œä¸ç”¨æ”¹</label>
    <input id="botId" value="0x626f745f7a753375703500000000000000000000000000000000000000000000" readonly>
  </div>
  <div class="field">
    <label>_botName (string) â€” å›ºå®šå€¼ï¼Œä¸ç”¨æ”¹</label>
    <input id="botName" value="SnakeBot_v2_01" readonly>
  </div>
  <div class="field">
    <label>_creator (address) â€” ç”¨æˆ·é’±åŒ…åœ°å€ï¼Œå›ºå®šå€¼ï¼Œä¸ç”¨æ”¹</label>
    <input id="creator" value="0xCF7C22507F5603f63Da8F4800d12EfC74C2cDf75" readonly>
  </div>
  <button onclick="createBot()">âœï¸ æ‰§è¡Œ createBot</button>
  <div id="createBot-status"></div>
</div>

<h2>ç¬¬äºŒæ­¥ï¼šé…ç½® NFT åˆçº¦åœ°å€ï¼ˆè®© Register æ—¶è‡ªåŠ¨ Mint NFTï¼‰</h2>
<div class="card">
  <p style="color:#888;font-size:13px">è°ƒç”¨ BotRegistry.setNFTContract()ï¼Œå°† SnakeBotNFT v2 åœ°å€å†™å…¥ BotRegistryï¼Œä¹‹åæ¯æ¬¡ç”¨æˆ· Register Bot éƒ½ä¼šè‡ªåŠ¨ Mint ä¸€ä¸ª NFTã€‚éœ€è¦ BotRegistry owner é’±åŒ…ç­¾åã€‚</p>
  <div class="field">
    <label>_nftContract (address) â€” SnakeBotNFT v2ï¼Œå›ºå®šå€¼ï¼Œä¸ç”¨æ”¹</label>
    <input id="nftContract" value="0xF269b84543041EA350921E3e3A2Da0B14B85453C" readonly>
  </div>
  <button onclick="setNFTContract()">âœï¸ æ‰§è¡Œ setNFTContract</button>
  <div id="setNFT-status"></div>
</div>

<script>
const CONTRACT = "0x93331E5596852ed9bB283fb142ac2bBc538F7DfC";
const BASE_SEPOLIA_CHAIN_ID = "0x14a34"; // 84532

const ABI_CREATE_BOT = {
  name: "createBot",
  type: "function",
  inputs: [
    { name: "_botId", type: "bytes32" },
    { name: "_botName", type: "string" },
    { name: "_creator", type: "address" }
  ]
};

const ABI_SET_BACKEND = {
  name: "setBackendWallet",
  type: "function",
  inputs: [{ name: "_backendWallet", type: "address" }]
};

function encodeABI(abi, params) {
  // Build the call data manually using eth_call encoding
  // We'll use window.ethereum.request with eth_sendTransaction
  return null; // handled below
}

function setStatus(id, msg, type) {
  const el = document.getElementById(id);
  el.className = "status " + type;
  el.innerHTML = msg;
}

async function connectWallet() {
  if (!window.ethereum) {
    setStatus("connect-status", "âŒ æœªæ£€æµ‹åˆ° MetaMaskï¼Œè¯·å…ˆå®‰è£…ã€‚", "err");
    return;
  }
  try {
    const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
    const chainId = await window.ethereum.request({ method: "eth_chainId" });

    if (chainId !== BASE_SEPOLIA_CHAIN_ID) {
      setStatus("connect-status", "âš ï¸ è¯·åˆ‡æ¢åˆ° Base Sepolia ç½‘ç»œï¼ˆChain ID: 84532ï¼‰", "err");
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: BASE_SEPOLIA_CHAIN_ID }]
        });
      } catch(e) {}
    }

    document.getElementById("wallet-display").textContent = accounts[0];
    setStatus("connect-status", "âœ… å·²è¿æ¥ï¼š" + accounts[0], "ok");
  } catch(e) {
    setStatus("connect-status", "âŒ " + e.message, "err");
  }
}

function encodeFunctionCall(funcSig, params) {
  // Simple ABI encoding for our specific cases
  // Using the interface from ethers-style encoding
  const keccak256 = async (str) => {
    const enc = new TextEncoder().encode(str);
    const hash = await crypto.subtle.digest("SHA-256", enc); // not keccak, need different approach
    return hash;
  };
  return null;
}

// We'll use eth_sendTransaction with pre-computed selectors
function hexEncode(str) {
  let hex = "";
  for (let i = 0; i < str.length; i++) {
    hex += str.charCodeAt(i).toString(16).padStart(2, "0");
  }
  return hex;
}

// Pre-computed 4-byte selectors
// createBot(bytes32,string,address) => computed offline
// setBackendWallet(address) => computed offline

async function sendTx(data) {
  const accounts = await window.ethereum.request({ method: "eth_accounts" });
  if (!accounts.length) {
    alert("è¯·å…ˆè¿æ¥é’±åŒ…");
    return null;
  }
  const txHash = await window.ethereum.request({
    method: "eth_sendTransaction",
    params: [{
      from: accounts[0],
      to: CONTRACT,
      data: data,
      gas: "0x30D40" // 200000
    }]
  });
  return txHash;
}

async function createBot() {
  const btn = event.target;
  btn.disabled = true;
  setStatus("createBot-status", "â³ ç­‰å¾…é’±åŒ…ç­¾å...", "info");
  try {
    // createBot(bytes32,string,address) selector: 0x46c37633
    // Encoding:
    // bytes32 botId: 0x626f745f7a753375703500000000000000000000000000000000000000000000
    // string offset: 0x60 (96 bytes - after the 3 fixed slots)
    // address creator: 0xCF7C22507F5603f63Da8F4800d12EfC74C2cDf75 (padded to 32 bytes)
    // string length: 14 ("SnakeBot_v2_01")
    // string data: 536e616b65426f745f76325f3031 padded to 32 bytes

    const selector = "46c37633";
    const botId = "626f745f7a753375703500000000000000000000000000000000000000000000";
    const stringOffset = "0000000000000000000000000000000000000000000000000000000000000060";
    const creator = "000000000000000000000000CF7C22507F5603f63Da8F4800d12EfC74C2cDf75";
    const stringLen = "000000000000000000000000000000000000000000000000000000000000000e"; // 14
    const stringData = "536e616b65426f745f76325f30310000000000000000000000000000000000000"; // "SnakeBot_v2_01" + 18 zero bytes = 32 bytes
    // Actually need exactly 32 bytes padded on right
    // "SnakeBot_v2_01" = 14 chars
    const name = "SnakeBot_v2_01";
    let nameHex = "";
    for (let i = 0; i < name.length; i++) nameHex += name.charCodeAt(i).toString(16).padStart(2, "0");
    while (nameHex.length < 64) nameHex += "00"; // pad to 32 bytes

    const data = "0x" + selector + botId + stringOffset + creator + stringLen + nameHex;

    const txHash = await sendTx(data);
    if (txHash) {
      setStatus("createBot-status", `âœ… äº¤æ˜“å·²å‘é€ï¼<br>Hash: <a href="https://sepolia.basescan.org/tx/${txHash}" target="_blank">${txHash}</a><br>ç­‰å¾…ç¡®è®¤åè¿›è¡Œç¬¬äºŒæ­¥ã€‚`, "ok");
    }
  } catch(e) {
    setStatus("createBot-status", "âŒ " + (e.message || e), "err");
  }
  btn.disabled = false;
}

async function setNFTContract() {
  const btn = event.target;
  btn.disabled = true;
  setStatus("setNFT-status", "â³ ç­‰å¾…é’±åŒ…ç­¾å...", "info");
  try {
    // setNFTContract(address) selector: keccak256("setNFTContract(address)") = 0xa7ccabdf
    const selector = "a7ccabdf";
    const addr = "000000000000000000000000F269b84543041EA350921E3e3A2Da0B14B85453C";
    const data = "0x" + selector + addr;

    const txHash = await sendTx(data);
    if (txHash) {
      setStatus("setNFT-status", `âœ… äº¤æ˜“å·²å‘é€ï¼<br>Hash: <a href="https://sepolia.basescan.org/tx/${txHash}" target="_blank">${txHash}</a><br>é…ç½®å®Œæˆåï¼Œç”¨æˆ· Register Bot æ—¶å°†è‡ªåŠ¨ Mint NFTã€‚`, "ok");
    }
  } catch(e) {
    setStatus("setNFT-status", "âŒ " + (e.message || e), "err");
  }
  btn.disabled = false;
}

// Auto-connect if already connected
window.addEventListener("load", async () => {
  if (window.ethereum) {
    const accounts = await window.ethereum.request({ method: "eth_accounts" });
    if (accounts.length) {
      document.getElementById("wallet-display").textContent = accounts[0];
    }
  }
});
</script>
</body>
</html>
